EOPI

6.1 (DUTCH NATIONAL FLAG) Write a function that takes an array A and an index i into A, and rearranges the elements such that all elements less than A[i] appear first, followed by elements equal to A[i], followed by elements greater than A[i]. Your algorithm should have O(1) space complexity and O(|A|) time complexity.

    MAIN IDEA:
        Maintain four groups using the following pointers:
            smaller:    end of BOTTOM           A[0...smaller-1]        <  pivot
            runner:     end of MIDDLE           A[smaller...runner-1]   == pivot
                        beginning of UNKNOWN    A[runner...bigger]      ?  pivot
            bigger:     beginning of TOP        A[bigger+1...length-1]  >  pivot
        Explore UNKNOWN items in order, swapping them into correct group
            item < pivot: swap into end of BOTTOM (increase size by 1), move on
            item == pivot: move on
            item > pivot: swap into beginning of TOP (increase size by 1)
        Each iteration decreases size of UNKNOWN group by 1

    ANALYSIS:
        TIME:   O(|A|)  Each iteration decreases unclassified group size by 1
        SPACE:  O(1)    Use smaller, runner, and larger pointers

    PSEUDOCODE:
        void dutchNationalFlag(int [] A, int index):
            pivot = A[index]
            smaller = 0, runner = 0, bigger = A.length - 1
            while runner <= bigger
                if A[runner] < pivot
                    swap(A, smaller++, runner++)// increase bottom shift middle
                else if A[runner] == pivot
                    runner++                    // increase middle
                else
                    swap(A, runner, bigger--)   // increase top

6.14 Check whether a 9x9 2D array representing a partially completed Sudoku is valid. Specifically, check that no row, column, and 3x3 2D subarray contains duplicates. A 0-value in the 2D array indicates the entry is blank; every other entry is in [1,9].

    MAIN IDEA:
        Create boolean array [1...9] of viable, iterate through
