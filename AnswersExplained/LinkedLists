EOPI

7.1 Let L and F be singly linked lists in which each node holds a number. Assume the numbers in L and F appear in ascending order witihin the lists. Write a function that takes L and F, and returns the merge of L and F. Your code should use O(1) additional storage - it should reuse the nodes from the lists provided as input. The only field you can change in a node is next.

    MAIN IDEA:
        Make pointers initialized to head of each list
        Make pointers to head and tail of M (the new list), initialized to null
        Iterate through the lists, comparing the values at both pointers
            If head is null, set head to the pointer of smaller value
            Else, set tail's next to pointer of smaller value
            set tail to be the pointer of the smaller value
            Advance the smaller valued pointer
        If one of the lists has more elements, add the elements

    ANALYSIS:

    PSEUDOCODE:
        LLNode mergeTwoSorted(L, F):
            p1 <- L
            p2 <- F
            head <- null
            tail <- null
            while p1 and p2 are both not null:
                ptr <- whichever out of p1 and p2 has smaller value
                if head is null
                    head <- ptr
                else
                    tail.next <- ptr
                tail <- ptr
                ptr = ptr.next
            if p1 not null:
                if head is null:
                    head <- p1
                else
                    tail.next <- p1
                tail <- p1
            if p2 not null:
                if head is null:
                    head <- p2
                else
                    tail.next <- p2
                tail <- p2
            return head

7.2 Given a reference to the head of a singly linked list L, how would you determine whether L ends in a null or reaches a cycle of nodes? Write a function that returns null if there does not exist a cycle and the reference to the start of the cycle if a cycle is present

    MAIN IDEA:
        Have two pointers, slow and fast
        Advance fast by 2 nodes each time, slow by only 1 node each time
        while fast is not null and fast.next is not null, keep advancing
            if slow == fast break
        if fast is null or fast.next is null
            return null
        reset slow to head of list
        while slow != fast, advance both pointers by 1 node
        return slow

    ANALYSIS:

    PSEUDOCODE:
        LLNode checkCyclicity(head)
            slow <- head
            fast <- head
            while fast != null and fast.next != null
                slow <- slow.next
                fast <- fast.next.next
                if slow == fast
                    break
            if fast == null or fast.next == null
                return null
            reset slow to head of list
            while slow != fast
                advance both pointers by 1 node
            return slow

7.4 Let h1 and h2 be the heads of lists L1 and L2, respectively. Assume that L1 and L2 are well-formed, that is each consists of a finite sequence of nodes. (In particular, neither list has a cycle.) How would you determine if there exists a node r reachable from both h1 and h2 by following the next fields? If such a node exists, find the node that appears earliest when traversing the lists. You are constrained to use no more than constant additional storage.
